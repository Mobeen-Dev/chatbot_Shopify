{{ 'styles.css' | asset_url | stylesheet_tag }}

<body>
  <!-- Chat Container -->
  <div id="chat-container">
    <!-- Chat Window -->
    <div id="chat-window">
      <!-- Chat Header -->
      <div id="chat-header">
        <h3>Product Assistant</h3>
        <span class="chat-icon" id="minimize-chat">remove</span>
      </div>

      <!-- Chat Messages -->
      <div id="chat-messages">
        <div class="message bot-message">
          Hi there! I'm your product assistant. Ask me about our products, and I'll show you some options.
        </div>
      </div>

      <!-- Chat Input Container -->
      <div id="chat-input-container">
        <textarea id="chat-input" placeholder="Type a message..."></textarea>
        <button id="send-button">
          <span class="chat-icon">send</span>
        </button>
      </div>
    </div>

    <!-- Chat Toggle Button -->
    <div id="chat-toggle">
      {% comment %} <span class="material-icons">chat</span> {% endcomment %}
      <span class="chat-icon">chat</span>
    </div>
  </div>

  <script>

        // Load Material Icons font inline without external dependencies
        (function() {
            // Only execute if Material Icons are not already loaded
            if (!document.getElementById('material-icons-font')) {
                // This will create a more limited set of material icons needed for the chatbot
                const iconFont = document.createElement('style');
                iconFont.id = 'material-icons-font';
                iconFont.textContent = `
                @font-face {
                    font-family: 'Material Icons';
                    font-style: normal;
                    font-weight: 400;
                    src: url('https://cdn.shopify.com/s/files/1/0744/0764/1366/files/MaterialIcons-Regular.ttf?v=1754460277') format('truetype');
                    font-display: block;
                }

                #chat-container .chat-icon {
                    font-family: 'Material Icons';
                    font-weight: normal;
                    font-style: normal;
                    font-size: 24px;
                    line-height: 1;
                    letter-spacing: normal;
                    text-transform: none;
                    display: inline-block;
                    white-space: nowrap;
                    direction: ltr;
                    -webkit-font-feature-settings: 'liga';
                    -webkit-font-smoothing: antialiased;
                    font-feature-settings: 'liga';
                }
            `;

                document.head.appendChild(iconFont);
            }
        })();

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize ChatBotService
            const chatService = new ChatBotService();
            
            // Initialize UI handlers
            chatService.initUI();
        });
        
        /**
         * ChatBotService - Handles communication with AI backend and UI interactions
         */
        class ChatBotService {
            constructor() {
                // DOM Elements
                this.chatToggle = document.getElementById('chat-toggle');
                this.chatWindow = document.getElementById('chat-window');
                this.minimizeChat = document.getElementById('minimize-chat');
                this.chatMessages = document.getElementById('chat-messages');
                this.chatInput = document.getElementById('chat-input');
                this.sendButton = document.getElementById('send-button');
                this.cartId = ""
                this.sessionId = ""
                
                // Configuration
                this.config = {
                    timeout: 500000,              // Maximum request timeout (ms)
                    maxRetries: 3,               // Maximum number of retry attempts
                    retryDelay: 1000,            // Base delay between retries (ms)
                    debounceDelay: 300,          // Debounce delay for input (ms)
                    apiEndpoint: '{{  block.settings.server_url }}',
                    {% comment %} apiEndpoint: 'http://127.0.0.1:8000/async-chat', {% endcomment %}
                    
                    maxConcurrentRequests: 2     // Limit concurrent API requests
                };
                
                // Conversation state
                this.conversationHistory = [];
                this.rememberMode = {{ block.settings.is_remember | default: false }};
                this.sessionId = null;
                {% comment %} this.getSessionId(); {% endcomment %}
                
                // Request state
                this.isProcessingRequest = false;
                this.abortController = null;
                this.requestQueue = [];
                this.isAITyping = false;
                
                // Performance optimization
                this.responseCache = new Map();
                
                // Sample product data
                this.products = [
                    {
                        id: 1,
                        title: "Arduino Uno R3",
                        price: "$22.99",
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODkzMjMzMzM4NjE4MTFFQTlCNDdFRDFCM0I3RTFFMUIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODkzMjMzMzQ4NjE4MTFFQTlCNDdFRDFCM0I3RTFFMUIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTMyMzMzMTg2MTgxMUVBOUI0N0VEMUIzQjdFMUUxQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTMyMzMzMjg2MTgxMUVBOUI0N0VEMUIzQjdFMUUxQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrMO5fAAAAINSURBVHja7JlNKMNhGMef18jbZiJlQouDg5ILTuRgoiZFDi5yQC5ycHFTSCmHdVKKHJTk5KIckYPIRaQoB5GXFAeSg5S8/Z/6/W2bsb9ZG8/z7Pn36enZ9uzh+X3f3/+ZoapGxWRRDIP2AR3QAR3QAR3QgX8lIIWlrfVZWQVms0UlJhpx3QZ+fDzCbrcTtLVzDCi4wDB0jJwcDYxGI65f4evrPbS0nIWxbOTnkI5tODi4hffvT3h+dgLMD5DL9QaTk9dQ8CVgRbHjrUV2dhpcXJzD2toRrK7uwvz8DXR0lEFFRQpERQn+DSGbzQQzM9dQXW2BuLgY/Ht1Lya8v7/H4uIZZGQkQVZWKvYXwvLyLszOOkCWfdYCkZHBTohk+PoKPSQmxmLBhXyJd3bOoKnJhsM3BH1VzOLidBge3ge7/cHrCcS5eXZ27sHy8pbwf0RKyrK7p6cCFhbGIC4u2l0zHr6S8lqL2tpZuLl5CMh6wk7I0FAF1Nfnua2iOHeTk1vQ1bUONzePPi+goAJms/GXu6OjG+/dnVCNKC7OAKOx0J0QnkLILS4BLpA3AltbJ9DYOAeXl7eeYoiB1NQkSE9P9plAQQUMBgmkpARSUmRoaipyF+rx8b3P1jHgjFpfPwKnE0PO6biYn4+LKnB1dYsJcuIeQg+PhP+1ky0E6b/W6oAO6IAO6IAO6AAP+RJgAMf82J3XjAurAAAAAElFTkSuQmCC",
                        link: "https://example.com/arduino-uno"
                    },
                    {
                        id: 2,
                        title: "Raspberry Pi 4 Model B",
                        price: "$45.99",
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDYxM0VBQkM4NjE4MTFFQTlFQURBNkJGQTRDQTFFNDciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDYxM0VBQUQ4NjE4MTFFQTlFQURBNkJGQTRDQTFFNDciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpENjEzRUFBQTg2MTgxMUVBOUVBREE2QkZBNENBMUU0NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpENjEzRUFBQjg2MTgxMUVBOUVBREE2QkZBNENBMUU0NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvRGsogAAALGSURBVHja7JlJaxRBFMfbcTdsJEzwIoERXC5JROOiI0EP7skH8NsPkI8geHHBJYhXjUQjuHgQvIgHF1wRFFxwAQXRICiCYdTMJOPM+F7xKmkmJtNJVVd3NfnDj4bu6qrqf1e/elV541iW5WhkK3IaHECAAAECBAgQ8J8JiOK9OyQSCcfn87m3e/n4HJ3BerFcLhflcvnCQlY8YYtVGo/Ho9FoFHuK2WzWzGQyplmWWuYMpunUQ5FIpK+np6dPUZQerD4/Qr8ymcwn07RKs7OzcVxPejmdxOK5OZLJZDgYDO6A+CRfU9O0z9Fo9Fyz2UzgRvGcCBgbG/NGo9F0KBRKQoDHAZbC4fCa8fHxAQjI5XI5zwmhBHR3d99RFCV2f/rDfuPa9s21vUPXZ3rD/n3jG9Npj9dr3TsNf2JiwhMIBL7BXqCWxOE3m2ZTEMoSQFPh/eDgoKkoyprOC7r6vrGlX795bzW+tPSTG9fv/1Jn6y0vOsVt7DlsBbPBYJBmcTX9hSeBtLCmmpLYF2TtdDrdD9+7sXu19+zW3UeP52XmWPQ5lrq2ZnR09BCWe2TGDdECOlDaD2Z4lVyxWJzC4hK2l9xCy9jUWrXg5SoBPgCWvIvK1Gq1L7THAjzQAQdL10tLS04JeA57i2eNs9lsp9AKJgEPYW+wcWg+n69UCTCFCqAz4YlQd9pI/mKx2GsGCAECBAgQIECAAAECli1A9Ag/EAR4hCmHi0qQGVsQYLu+ER6CLMGzgMULCONQhDNUHBk6jxACJAu4Wq1Wy+Vy2YnxXVHUwcFBV1m42C70G6UU9/f3i+tCeQF5Ato1rj7Z2Nh4ZXp6+mipVLpYqVQeVqvVZ6gu/K7X66/r9frzRqPxcmZm5jYEdMqc+4JWBK2G9cBWwbqQHJW1vxKFRaGQcF3/O1mggAABAgQIECBAgID/Ur4LMACoq+k4iC5JkQAAAABJRU5ErkJggg==",
                        link: "https://example.com/raspberry-pi-4"
                    },
                    {
                        id: 3,
                        title: "ESP32 Development Board",
                        price: "$10.99",
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODkzMjMzMzM4NjE4MTFFQTlCNDdFRDFCM0I3RTFFMUIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODkzMjMzMzQ4NjE4MTFFQTlCNDdFRDFCM0I3RTFFMUIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTMyMzMzMTg2MTgxMUVBOUI0N0VEMUIzQjdFMUUxQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTMyMzMzMjg2MTgxMUVBOUI0N0VEMUIzQjdFMUUxQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrMO5fAAAAINSURBVHja7JlNKMNhGMef18jbZiJlQouDg5ILTuRgoiZFDi5yQC5ycHFTSCmHdVKKHJTk5KIckYPIRaQoB5GXFAeSg5S8/Z/6/W2bsb9ZG8/z7Pn36enZ9uzh+X3f3/+ZoapGxWRRDIP2AR3QAR3QAR3QgX8lIIWlrfVZWQVms0UlJhpx3QZ+fDzCbrcTtLVzDCi4wDB0jJwcDYxGI65f4evrPbS0nIWxbOTnkI5tODi4hffvT3h+dgLMD5DL9QaTk9dQ8CVgRbHjrUV2dhpcXJzD2toRrK7uwvz8DXR0lEFFRQpERQn+DSGbzQQzM9dQXW2BuLgY/Ht1Lya8v7/H4uIZZGQkQVZWKvYXwvLyLszOOkCWfdYCkZHBTohk+PoKPSQmxmLBhXyJd3bOoKnJhsM3BH1VzOLidBge3ge7/cHrCcS5eXZ27sHy8pbwf0RKyrK7p6cCFhbGIC4u2l0zHr6S8lqL2tpZuLl5CMh6wk7I0FAF1Nfnua2iOHeTk1vQ1bUONzePPi+goAJms/GXu6OjG+/dnVCNKC7OAKOx0J0QnkLILS4BLpA3AltbJ9DYOAeXl7eeYoiB1NQkSE9P9plAQQUMBgmkpARSUmRoaipyF+rx8b3P1jHgjFpfPwKnE0PO6biYn4+LKnB1dYsJcuIeQg+PhP+1ky0E6b/W6oAO6IAO6IAO6AAP+RJgAMf82J3XjAurAAAAAElFTkSuQmCC",
                        link: "https://example.com/esp32"
                    }
                ];
                
                // Add chat header options
                this.addHeaderOptions();
            }
            
            /**
             * Initialize UI event handlers
             */
            initUI() {
                // Toggle chat window
                this.chatToggle.addEventListener('click', () => this.toggleChatWindow());
                
                // Minimize chat
                this.minimizeChat.addEventListener('click', () => this.minimizeChatWindow());
                
                // Send button click
                this.sendButton.addEventListener('click', () => this.sendMessage());
                
                // Enter key press
                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent default behavior (new line)
                        this.sendMessage();
                    }
                });
                
                // Auto-resize textarea based on content
                this.chatInput.addEventListener('input', function() {
                    // Reset height to auto to properly calculate the new height
                    this.style.height = 'auto';
                    
                    // Set new height based on scrollHeight (content height)
                    // Limit to max-height defined in CSS
                    const newHeight = Math.min(this.scrollHeight, 120);
                    this.style.height = newHeight + 'px';
                });
                
                // Add welcome message
                // this.addMessage("Hi there! I'm your product assistant. Ask me about our products, and I'll show you some options.", 'bot');
            }
            
            // Add options to chat header
            addHeaderOptions() {
                return; // Skip already added
                const headerElement = document.getElementById('chat-header');
                
                // Create memory mode toggle
                const memoryToggle = document.createElement('div');
                memoryToggle.classList.add('header-option');
                memoryToggle.innerHTML = '<span class="chat-icon">memory</span>';
                memoryToggle.title = "Toggle Memory Mode";
                memoryToggle.addEventListener('click', () => this.toggleRememberMode());
                
                // Create reset button
                const resetButton = document.createElement('div');
                resetButton.classList.add('header-option');
                resetButton.innerHTML = '<span class="chat-icon">refresh</span>';
                resetButton.title = "Reset Conversation";
                resetButton.addEventListener('click', () => this.resetConversation());
                
                // Add the options to header
                headerElement.insertBefore(resetButton, this.minimizeChat);
                headerElement.insertBefore(memoryToggle, resetButton);
            }
            
            
            // Toggle chat window visibility            
            toggleChatWindow() {
                this.chatWindow.classList.toggle('open');
                
                // Change icon based on state
                const icon = this.chatToggle.querySelector('.chat-icon');
                if (this.chatWindow.classList.contains('open')) {
                    icon.textContent = 'close';
                    this.chatInput.focus();
                } else {
                    icon.textContent = 'chat';
                }
            }
            
            // Minimize chat window            
            minimizeChatWindow() {
                this.chatWindow.classList.remove('open');
                this.chatToggle.querySelector('.chat-icon').textContent = 'chat';
            }
            
            
            // Send user message to AI and process response            
            async sendMessage() {
                let message = this.chatInput.value.trim();
                if (!message || this.isAITyping) return;
                
                this.addMessage(message, 'user');
                this.chatInput.value = '';
                this.chatInput.style.height = 'auto';

                // Add to conversation history if remember mode is on
                if (!this.rememberMode) {
                    this.conversationHistory.push({ role: 'user', content: message });
                }

                if (this.sessionId) {
                message += `\n    session_id: ${this.sessionId} -- Used only for cart related functions/tools`;
                }
                
                // Disable input while AI is processing
                this.setInputDisabled(true);
                this.showTypingIndicator();
                
                try {
                    const response = await this.getAIResponse(message);
                    console.log(`Line 633 getAIResponse : ${JSON.stringify(response)}`);
                    this.hideTypingIndicator();
                    
                    console.log(`Received Formatted response: ${response}`);  
                    // Process different response types
                    if (typeof response.reply === 'string') {
                        this.addMessage(response.reply, 'bot');
                    }
                    let productList = [];

                    if (response.stuctural_data && response.stuctural_data.length > 0) {
                        response.stuctural_data.forEach((data) => {
                            if (data.type === "Product") {
                                productList.push(data);
                            } else if (data.type === "Cart") {
                                this.addCartFromResponse(data);
                            } else if (data.type === "Order") {
                                this.addOrderFromResponse(data);
                            }
                        });

                        if (productList.length > 0) {
                            this.addProductsFromResponse(productList);
                        }
                    }
                    
                    // Add AI response to history if remember mode is on
                    if (!this.rememberMode) {
                        this.conversationHistory.push({ 
                            role: 'assistant', 
                            content: typeof response === 'string' ? response : JSON.stringify(response)
                        });
                    }
                } catch (error) {
                    this.hideTypingIndicator();
                    this.handleError(error);
                } finally {
                    this.setInputDisabled(false);
                }
            }
            
            
            // Make API request to the backend
            
            async makeRequest(data, retryCount = 0) {
                try {
                    console.log(`Sending request with data: ${JSON.stringify(data)}`);
                    
                    // Set up abort controller with timeout
                    this.abortController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        this.abortController.abort();
                        throw new Error('Request timeout');
                    }, this.config.timeout);
                    
                    const response = await fetch(this.config.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify(data),
                        signal: this.abortController.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.error) {
                        throw new Error(result.error || 'Unknown server error');
                    }
                    this.sessionId = result.session_id;
                    console.log(`Received response: ${JSON.stringify(result)}`);
                    return result;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request was cancelled');
                    }
                    
                    if (error.message === 'Request timeout') {
                        throw new Error('Server response timeout (30s)');
                    }
                    
                    // Retry logic for network errors
                    if (retryCount < this.config.maxRetries && this.isRetryableError(error)) {
                        await this.delay(this.config.retryDelay * Math.pow(2, retryCount));
                        return this.makeRequest(data, retryCount + 1);
                    }
                    
                    throw error;
                }
            }
            
            renderMarkdown(text) {
                if (!text) return '';
                
                let html = text;
                
                // Store code blocks to avoid processing markdown inside them
                const codeBlocks = [];
                const inlineCodes = [];
                
                // Extract and store fenced code blocks first
                html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                    const index = codeBlocks.length;
                    codeBlocks.push(`<pre><code${lang ? ` class="language-${lang}"` : ''}>${this.escapeHtml(code.trim())}</code></pre>`);
                    return `__CODE_BLOCK_${index}__`;
                });
                
                // Extract and store inline code
                html = html.replace(/`([^`]+)`/g, (match, code) => {
                    const index = inlineCodes.length;
                    inlineCodes.push(`<code>${this.escapeHtml(code)}</code>`);
                    return `__INLINE_CODE_${index}__`;
                });
                
                // Handle horizontal rules
                html = html.replace(/^---+$/gm, '<hr>');
                
                // Handle headings
                html = html.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, text) => {
                    const level = hashes.length;
                    return `<h${level}>${text.trim()}</h${level}>`;
                });
                
                // Handle blockquotes
                html = html.replace(/^>\s*(.+)$/gm, '<blockquote>$1</blockquote>');
                // Merge adjacent blockquotes
                html = html.replace(/(<\/blockquote>\s*<blockquote>)/g, '<br>');
                
                // Handle tables
                html = html.replace(/^\|(.+)\|\s*\n\|([:\-\s\|]+)\|\s*\n((?:\|.+\|\s*\n?)*)/gm, (match, header, separator, rows) => {
                    const headerCells = header.split('|').map(cell => `<th>${cell.trim()}</th>`).join('');
                    const rowsHtml = rows.trim().split('\n').map(row => {
                        const cells = row.split('|').slice(1, -1).map(cell => `<td>${cell.trim()}</td>`).join('');
                        return `<tr>${cells}</tr>`;
                    }).join('');
                    return `<table><thead><tr>${headerCells}</tr></thead><tbody>${rowsHtml}</tbody></table>`;
                });
                
                // Handle links
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                
                // Handle bold text (**text** or __text__)
                html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
                
                // Handle italic text (*text* or _text_) - be careful not to conflict with bold
                html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
                
                // Handle lists - first split into lines for processing
                const lines = html.split('\n');
                const processedLines = [];
                let inList = false;
                let listType = null;
                let listItems = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    // Check for ordered list items
                    const orderedMatch = line.match(/^(\d+)\.\s+(.+)/);
                    // Check for unordered list items
                    const unorderedMatch = line.match(/^[\-\*\+]\s+(.+)/);
                    
                    if (orderedMatch) {
                        if (!inList || listType !== 'ol') {
                            if (inList) {
                                // Close previous list
                                processedLines.push(`</${listType}>`);
                            }
                            listType = 'ol';
                            inList = true;
                            listItems = [];
                        }
                        listItems.push(`<li>${orderedMatch[2]}</li>`);
                    } else if (unorderedMatch) {
                        if (!inList || listType !== 'ul') {
                            if (inList) {
                                // Close previous list
                                processedLines.push(`</${listType}>`);
                            }
                            listType = 'ul';
                            inList = true;
                            listItems = [];
                        }
                        listItems.push(`<li>${unorderedMatch[1]}</li>`);
                    } else {
                        // Not a list item
                        if (inList) {
                            // Close the list
                            processedLines.push(`<${listType}>`);
                            processedLines.push(...listItems);
                            processedLines.push(`</${listType}>`);
                            inList = false;
                            listType = null;
                            listItems = [];
                        }
                        processedLines.push(line);
                    }
                }
                
                // Close any remaining list
                if (inList) {
                    processedLines.push(`<${listType}>`);
                    processedLines.push(...listItems);
                    processedLines.push(`</${listType}>`);
                }
                
                html = processedLines.join('\n');
                
                // Handle paragraph breaks (double line breaks become paragraph breaks)
                html = html.replace(/\n\s*\n/g, '</p><p>');
                
                // Wrap in paragraphs if there's content
                if (html.trim()) {
                    // Don't wrap block elements in paragraphs
                    const blockElements = /^(<h[1-6]|<hr|<blockquote|<table|<[uo]l|<pre)/;
                    if (!blockElements.test(html.trim())) {
                        html = `<p>${html}</p>`;
                    }
                }
                
                // Handle single line breaks
                html = html.replace(/\n/g, '<br>');
                
                // Restore code blocks
                codeBlocks.forEach((code, index) => {
                    html = html.replace(`__CODE_BLOCK_${index}__`, code);
                });
                
                // Restore inline code
                inlineCodes.forEach((code, index) => {
                    html = html.replace(`__INLINE_CODE_${index}__`, code);
                });
                
                return html;
            }

            // Helper function to escape HTML characters
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Get AI response - with caching
            
            async getAIResponse(message) {
                // Check cache first for performance
                const cacheKey = this.rememberMode ? 
                    `${message}_${JSON.stringify(this.conversationHistory)}` : 
                    message;
                
                {% comment %} 
                if (this.responseCache.has(cacheKey)) {
                    // Simulate network delay for cached responses
                    await this.delay(500 + Math.random() * 1000);
                    return this.responseCache.get(cacheKey);
                } 
                {% endcomment %}
                
                const requestData = {
                    message: message,
                    {% comment %} history: this.rememberMode ? this.conversationHistory : [], {% endcomment %}
                    session_id: this.sessionId
                };
                let response = await this.makeRequest(requestData);
                this.conversationHistory = response.history;
                const reply = response.reply; 

                if (response.cart_id !== null && response.cart_id !== undefined) {
                this.cartId = response.cart_id;
                }

                if (response.session_id !== null && response.session_id !== undefined) {
                this.sessionId = response.session_id;
                }
                
                
                // Cache the response
                this.responseCache.set(cacheKey, reply);
                
                // Limit cache size for memory management
                if (this.responseCache.size > 100) {
                    const firstKey = this.responseCache.keys().next().value;
                    this.responseCache.delete(firstKey);
                }

                const formattedReply = this.renderMarkdown(reply);                
                {% comment %} return formattedReply; {% endcomment %}
                
                response.reply = formattedReply
                return response
            }
            
            
            // Simulate API response for demo purposes
            // In production, this would be replaced with actual API calls
            
            async simulateAPIResponse(message) {
                const lowerMessage = message.toLowerCase();
                await this.delay(1000 + Math.random() * 2000); // Simulate network delay
                
                // Check if message contains keywords for microcontrollers
                if (lowerMessage.includes('arduino') || 
                    lowerMessage.includes('microcontroller') || 
                    lowerMessage.includes('raspberry') || 
                    lowerMessage.includes('controller') || 
                    lowerMessage.includes('board') || 
                    lowerMessage.includes('electronic')) {
                    
                    // Return product list response
                    return {
                        type: 'products',
                        message: "Here are some products you might be interested in:",
                        products: this.products
                    };
                } 
                // Check if asking for specific product
                else if (lowerMessage.includes('arduino uno')) {
                    return {
                        type: 'products',
                        message: "Here's the Arduino Uno you asked about:",
                        products: [this.products[0]]
                    };
                }
                else if (lowerMessage.includes('raspberry pi')) {
                    return {
                        type: 'products',
                        message: "Here's the Raspberry Pi you asked about:",
                        products: [this.products[1]]
                    };
                }
                else if (lowerMessage.includes('esp32')) {
                    return {
                        type: 'products',
                        message: "Here's the ESP32 you asked about:",
                        products: [this.products[2]]
                    };
                }
                else if (lowerMessage.includes('memory') || lowerMessage.includes('remember')) {
                    return `Memory mode is currently ${this.rememberMode ? 'enabled' : 'disabled'}. You can toggle it by clicking the memory icon in the header.`;
                }
                else if (lowerMessage.includes('reset') || lowerMessage.includes('clear')) {
                    return "You can reset our conversation by clicking the refresh icon in the header.";
                }
                // Handle "remember mode" context
                else if (this.rememberMode && this.conversationHistory.length > 0) {
                    // Example of using context in responses
                    const userMentionedProducts = this.conversationHistory.some(msg => 
                        msg.role === 'user' && 
                        (msg.content.toLowerCase().includes('arduino') || 
                         msg.content.toLowerCase().includes('raspberry') ||
                         msg.content.toLowerCase().includes('esp32'))
                    );
                    
                    if (userMentionedProducts && (lowerMessage.includes('price') || lowerMessage.includes('cost'))) {
                        return "Based on our conversation, I see you're interested in our microcontrollers. Prices range from $10.99 for the ESP32 to $45.99 for the Raspberry Pi 4.";
                    }
                }
                
                // Default response
                return "I can help you find microcontrollers and development boards. Try asking about Arduino, Raspberry Pi, or ESP32!";
            }
            
            
            // Check if error is retryable            
            isRetryableError(error) {
                const retryableErrors = [
                    'NetworkError',
                    'TypeError',
                    'Failed to fetch'
                ];
                return retryableErrors.some(errorType => 
                    error.message.includes(errorType) || error.name === errorType
                );
            }
            
            
            // Handle errors with user-friendly messages
            handleError(error) {
                console.error('ChatBot error:', error);
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 'message error-message';
                errorDiv.textContent = `Error: ${error.message}`;
                this.chatMessages.appendChild(errorDiv);
                this.scrollToBottom();
                
                // Auto-remove error message after 5 seconds
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 5000);
            }
            
            // Get or create session ID            
            getSessionId() {
                return null;
                // Using a basic session ID generation method to avoid localStorage
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            // Toggle remember mode
            toggleRememberMode() {
                this.rememberMode = !this.rememberMode;
                return;
                // Show feedback
                const mode = this.rememberMode ? 'enabled' : 'disabled';
                this.addSystemMessage(`Memory Mode ${mode}. ${this.rememberMode ? 'I will now remember our conversation context.' : 'Conversation context will not be saved.'}`);
            }
            
            // Reset conversation
            resetConversation() {
                // Clear conversation history
                this.conversationHistory = [];
                
                // Clear chat messages
                while (this.chatMessages.firstChild) {
                    this.chatMessages.removeChild(this.chatMessages.firstChild);
                }
                
                // Cancel any pending requests
                if (this.abortController) {
                    this.abortController.abort();
                }
                
                // Clear cache
                this.responseCache.clear();
                
                // Generate new session ID
                this.sessionId = null;
                {% comment %} this.sessionId = this.getSessionId(); {% endcomment %}
                
                // Add welcome message
                this.addSystemMessage('Conversation has been reset.');
                this.addMessage("Hi there! I'm your product assistant. Ask me about our products, and I'll show you some options.", 'bot');
            }
            
            // Cleanup resources
            cleanup() {
                if (this.abortController) {
                    this.abortController.abort();
                }
                this.responseCache.clear();
            }
            
            // Add message to chat
            addMessage(text, sender) {
                if (text.trim() === '') return;
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message');
                messageDiv.classList.add(sender + '-message');
                messageDiv.innerHTML  = text;
                {% comment %} messageDiv.textContent  = text; {% endcomment %}
                this.chatMessages.appendChild(messageDiv);
                
                this.scrollToBottom();
            }
            
            // Add system message to chat (for notifications)
            addSystemMessage(text) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', 'system-message');
                messageDiv.innerHTML  = text;
                this.chatMessages.appendChild(messageDiv);
                
                this.scrollToBottom();
                
                // Auto-remove system message after 5 seconds
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.style.opacity = '0';
                        setTimeout(() => {
                            if (messageDiv.parentNode) {
                                messageDiv.remove();
                            }
                        }, 300);
                    }
                }, 5000);
            }
            
            // Add products from response
            addProductsFromResponse(products) {
                // Add intro message
                this.addMessage("Products recommendations :", 'bot');
                
                const sortedProducts = products.sort((a, b) => {
                    const priceA = parseFloat(a.price.slice(0, -4)) || 0;
                    const priceB = parseFloat(b.price.slice(0, -4)) || 0;
                    return priceA - priceB; // ascending
                });

                // Add each product
                sortedProducts.forEach((product, index) => {
                    setTimeout(() => {
                        this.addProduct(product);
                    }, index * 300);
                });
            }
            
            // Add product to chat
            addProduct(product) {
                const message = JSON.stringify(product.description);
                this.addMessage(message.slice(1, -1), 'bot');
                const productDiv = document.createElement('div');
                productDiv.classList.add('message', 'bot-message');
                
                const productLink = document.createElement('a');
                productLink.classList.add('product-card');
                productLink.href = product.link;
                productLink.target = "_blank";
                productLink.rel = "noopener noreferrer";
                productLink.innerHTML = `
                    <img src=${product.imageurl} alt="${product.title}" class="product-image">
                    
                    <div class="product-info">
                        <h4 class="product-title">${product.title}</h4>
                        <p class="product-price">${product.price}</p>
                    </div>
                `;
                
                productDiv.appendChild(productLink);
                this.chatMessages.appendChild(productDiv);
                
                this.scrollToBottom();
            }
            
            // Add cart from response
            addCartFromResponse(cart) {
                const cartDiv = document.createElement('div');
                cartDiv.classList.add('message', 'bot-message', 'cart-wrapper');

                let html = `<p class="cart-header">ðŸ›’ Here's your cart:</p>`;
                html += `<hr class="cart-header-divider">`;

                if (!cart.lineItems) {
                    html += `<p>Your cart is empty.</p><hr class="divider">`;
                } else {
                    html += `<div class="cart-products">`;

                    cart.lineItems.forEach((item, index) => {
                        const title = item.merchandise_title || "Unnamed product";
                        const qty = item.quantity || 1;
                        const price = item.merchandise_price || "Price Not Confirmed";

                        // Truncate long product names
                        const safeTitle = title.length > 50 ? title.slice(0, 50) + "â€¦" : title;

                        html += `
                            <div class="cart-item">
                                <span class="cart-title">${safeTitle}</span>
                                <span class="cart-price">${price} Ã— ${qty}</span>
                            </div>
                        `;
                        if (index < cart.lineItems.length - 1) {
                            html += `<hr class="divider">`;
                        }
                    });

                    html += `</div>`;
                    html += `<hr class="divider subtotal-divider">`;
                    html += `<p class="subtotal">Subtotal: ${cart.subtotalAmount || "$0.00"}</p>`;

                    if (cart.checkoutUrl) {
                        html += `
                            <a class="checkout-link" href="${cart.checkoutUrl}" target="_blank" rel="noopener noreferrer">
                                Proceed to Checkout â€” ${cart.subtotalAmount || ""}
                            </a>
                        `;
                    }
                }

                cartDiv.innerHTML = html;
                this.chatMessages.appendChild(cartDiv);

                // Always scroll chat down
                this.scrollToBottom();
            }
            
            // Render order summary in chat
            addOrderFromResponse(order) {
                const chatMessages = document.getElementById("chat-messages");

                const orderDiv = document.createElement("div");
                orderDiv.classList.add("message", "bot-message", "order-wrapper");

                let html = `<p class="order-header">ðŸ“¦ Your Order Summary</p>`;
                html += `<hr class="order-divider">`;

                // Safe extractors
                const safe = (val, fallback = "â€”") => (val && String(val).trim() ? val : fallback);

                html += `
                    <div class="order-info">
                        <div class="order-row"><strong>Order ID:</strong> ${safe(order.OrderID)}</div>
                        <div class="order-row"><strong>Status:</strong> ${safe(order.FinancialStatus)} / ${safe(order.FulfillmentStatus)}</div>
                        <div class="order-row"><strong>Customer:</strong> ${safe(order.CustomerName)}</div>
                        <div class="order-row"><strong>Phone:</strong> ${safe(order.CustomerPhone)}</div>
                        <div class="order-row"><strong>Email:</strong> ${safe(order.CustomerEmail)}</div>
                `;

                {% comment %} if (order.Items) {
                    html += `<div class="order-row"><strong>Items:</strong> ${order.Items}</div>`;
                } {% endcomment %}

                if (order.Items) {
                    const items = order.Items.split("^break^");
                    console.log(items)
                    let itemsHtml = "<div class='order-row'><strong>Items:</strong><br>";

                    items.forEach((item, index) => {
                        itemsHtml += `${item.trim()}`;
                        if (index < items.length - 1) {
                            itemsHtml += "<br>"; // add line break between items
                        }
                    });

                    itemsHtml += "</div>";
                    html += itemsHtml;
                }

                if (order.ShippingAddress) {
                    html += `<div class="order-row"><strong>Ship To:</strong> ${order.ShippingAddress}</div>`;
                }

                html += `
                        <div class="order-row total"><strong>Total:</strong> ${safe(order.Total, "$0.00")}</div>
                    </div>
                `;

                orderDiv.innerHTML = html;
                chatMessages.appendChild(orderDiv);

                // Auto scroll
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }




            // Add individual cart item
            addCartItem(item) {
                const productDiv = document.createElement('div');
                productDiv.classList.add('message', 'bot-message');

                const productLink = document.createElement('div');
                productLink.classList.add('product-card');

                // Assuming item has merchandise name, qty, and price
                const title = item.merchandise?.title || "Unnamed product";
                const qty = item.quantity || 1;
                const price = item.price || "";

                productLink.innerHTML = `
                    <div class="product-info">
                        <h4 class="product-title">${title}</h4>
                        <p class="product-price">${price} Ã— ${qty}</p>
                    </div>
                `;

                productDiv.appendChild(productLink);
                this.chatMessages.appendChild(productDiv);
                this.scrollToBottom();
            }

            
            // Show typing indicator
            showTypingIndicator() {
                this.isAITyping = true;
                const typingDiv = document.createElement('div');
                typingDiv.classList.add('typing-indicator');
                typingDiv.innerHTML = `
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <span class="text">Assistant is typing...</span>
                `;
                typingDiv.id = 'typing-indicator';
                this.chatMessages.appendChild(typingDiv);
                
                this.scrollToBottom();
            }
            
            // Hide typing indicator
            hideTypingIndicator() {
                this.isAITyping = false;
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }
            
            // Set input disabled state
            setInputDisabled(disabled) {
                this.chatInput.disabled = disabled;
                this.sendButton.disabled = disabled;
                
                if (!disabled) {
                    this.chatInput.focus();
                }
            }
            
            // Scroll chat to bottom
            scrollToBottom() {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }
            
            // Utility function for delays
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
  </script>
</body>

{% schema %}
{
  "name": "Testing ChatBot Button",
  "target": "body",
  "settings": [
    {
      "type": "url",
      "id": "server_url",
      "label": "Server Link"
    },
    {
      "type": "url",
      "id": "mcp_link",
      "label": "MCP URL"
    },
    {
      "type": "checkbox",
      "id": "is_remember",
      "label": "Remembers Context",
      "default": true
    },
    {
      "type": "range",
      "id": "temperature",
      "min": 0,
      "max": 2,
      "step": 0.1,
      "unit": "tmp",
      "label": "Model Temperature",
      "default": 1
    }
  ]
}
{% endschema %}
